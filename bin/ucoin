#!/usr/bin/env node
var request   = require('request');
var program   = require('commander');
var vucoin    = require('../index');
var hdc       = require('hdc');
var fs        = require('fs');
var sha1      = require('sha1');
var async     = require('async');
var _         = require('underscore');
var merkle    = require('merkle');
var Table     = require('cli-table');
var moment    = require('moment');
var inquirer  = require('inquirer');
var mkdirp    = require('mkdirp');
var crypto    = require('../lib/crypto');
var base58    = require('../lib/base58');
var ask       = require('../lib/ask');
var jsonpckg  = require('../package');
var stdinData = '';

// Consts
var NO_AUTH = false;
var REG_PUBKEY = /^[123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz]{43,44}$/;

// Default values
program.host = "localhost";
program.port = "8081";

program
  .version(jsonpckg.version)
  .option('--key <keyFile>', 'File of the key to submit.')
  .option('--search <search>', 'Search string')
  .option('--votefile <voteFile>', 'Vote file to send.')
  .option('--sender <fingerprint>', 'Sender\'s fingerprint.')
  .option('--recipient <fingerprint', 'Recipient\'s fingerprint.')
  .option('--certs', 'If present with import-lookup, also add certifications of the identity.')
  .option('--transaction <txFile>', 'Transaction file to send.')
  .option('--membership <msFile>', 'Membership file to send.')
  .option('-c, --currency <name>', 'Currency name.')
  .option('-t, --timestamp <timestamp>', 'Timestamp used for GeneratedOn field in amendment.', parseInt)
  .option('-h, --host <address>', 'DNS, IPv4 or IPv6 address of the node to contact.')
  .option('-p, --port <port>', 'Port of the node to contact.')
  .option('--user <user>', 'Alias for storing data in a specific folder. Default to \'default\'')
  .option('--salt <salt>', 'Salt string')
  .option('--passwd <password>', 'Password of the key')
  .option('--store', 'Store data instead of writing to sdout')
  .option('--send', 'send data instead of writing to sdout')
  .option('-y, --yes', 'Do not ask any confirmation')

program
  .command('sec')
  .description('Get base58 secret key using --salt & --password parameters')
  .action(withKeyPair(function (pub, sec) {
    console.log(base58.encode(sec));
  }));

program
  .command('pub')
  .description('Get base58 public key using --salt & --password parameters')
  .action(withKeyPair(function (pub, sec) {
    console.log(base58.encode(pub));
  }));

program
  .command('self [uid]')
  .description('Build self-certification.')
  .action(withKeyPair(function (pub, sec, uid) {
    async.waterfall([
      function (next){
        if (uid) createSelfCert(pub, sec, uid, next);
        else readSelfCert(next);
      },
    ], handleError(function (selfCert) {
      if (program.store)
        writeInHome("self", selfCert);
      if (program.send)
        withConnection(function (node) {
          node.wot.add(base58.encode(pub), selfCert.split('\n').slice(1).join('\n'), '', function (err) {
            if (err) console.error('Error:', err);
            else console.log('Successfully sent identity \'' + uid + '\'');
          })
        })();
      if (!program.send && !program.store)
        process.stdout.write(selfCert);
    }));
  }));

function createSelfCert (pub, sec, uid, done) {
    var raw = "";
    async.waterfall([
      function (next){
        raw += base58.encode(pub) + '\n';
        raw += "UID:" + uid + '\n';
        raw += "META:TS:" + new Date().utcZero().timestamp() + '\n';
        var selfCert = raw.split('\n').slice(1).join('\n');
        crypto.sign(selfCert, sec, next);
      },
      function (sig, next){
        raw += sig + '\n';
        next(null, raw);
      },
    ], done);
}

function readSelfCert (done) {
  done(null, readInHome('self'));
}

program
  .command('join [uid] [certts]')
  .description('Send join membership request.')
  .action(withKeyPair(function (pub, sec, uid, certts) {
    var certts = 0;
    async.waterfall([
      function (next){
        if (!uid){
          next('User ID is required');
          return;
        }
        if (certts) {
          next(null, certts);
        } else {
          // Look for possible certts
          async.waterfall([
            function (next) {
              withConnection(function (node){
                node.wot.lookup(decodeURIComponent(uid), next);
              })();
            },
            function (res, next){
              var matches = [];
              var hash = {};
              res.results.forEach(function(pubres){
                matches[pubres.pubkey] = [];
                pubres.uids.forEach(function(uidres){
                  var choice = uidres.meta.timestamp + ' ' + uidres.uid;
                  hash[choice] = uidres.meta.timestamp + ' ' + uidres.uid;
                  matches.push(choice);
                });
              });
              if (matches.length == 0)
                next('No matching identity found on server');
              else {
                if (matches.length == 1)
                  next(null, matches[matches.length-1]);
                else {
                  matches = matches.concat(["None"]);
                  ask.pick("Which one to use for membership?", matches, matches[matches.length-1], function (err, said) {
                    if (said == 'None')
                      next('Aborted.');
                    else
                      next(null, hash[said]);
                  });
                }
              }
            },
          ], next);
        }
      },
      function (ts, next) {
        certts = parseInt(ts.split(' ')[0]);
        withConnection(function (node) {
          async.parallel({
            current: function (next) {
              node.blockchain.current(function (err, current) {
                next(null, err ? null : current);
              });
            },
            parameters: function (next) {
              node.blockchain.parameters(function (err, json) {
                next(err, json);
              });
            }
          }, next);
        })();
      },
      function (res, next){
        var number = res.current ? res.current.number : 0;
        var hash = res.current ? res.current.hash : 'DA39A3EE5E6B4B0D3255BFEF95601890AFD80709';
        createMembership('IN', res.parameters.currency, pub, sec, number, hash, uid, certts, next);
      },
    ], handleError(function (signedMS) {
      if (program.store)
        writeInHome("join", signedMS);
      if (program.send)
        withConnection(function (node) {
          node.blockchain.membership(signedMS, function (err) {
            if (err) console.error('Error:', err);
            else console.log('Successfully sent join membership.');
          })
        })();
      if (!program.send && !program.store)
        process.stdout.write(signedMS);
    }));
  }));

program
  .command('renew [uid]')
  .description('Send active membership request.')
  .action(withKeyPair(function (pub, sec, uid) {
    var certts = 0;
    async.waterfall([
      function (next){
        if (!uid){
          next('User ID is required');
          return;
        }
        // Look for possible certts
        async.waterfall([
          function (next) {
            withConnection(function (node){
              node.blockchain.memberships(decodeURIComponent(uid), next);
            })();
          },
          function (res, next){
            certts = res.sigDate;
            next();
          }
        ], next);
      },
      function (next) {
        withConnection(function (node) {
          async.parallel({
            current: function (next) {
              node.blockchain.current(function (err, current) {
                next(null, err ? null : current);
              });
            },
            parameters: function (next) {
              node.blockchain.parameters(function (err, json) {
                next(err, json);
              });
            }
          }, next);
        })();
      },
      function (res, next){
        var number = res.current ? res.current.number : 0;
        var hash = res.current ? res.current.hash : 'DA39A3EE5E6B4B0D3255BFEF95601890AFD80709';
        createMembership('IN', res.parameters.currency, pub, sec, number, hash, uid, certts, next);
      },
    ], handleError(function (signedMS) {
      if (program.store)
        writeInHome("renew", signedMS);
      if (program.send)
        withConnection(function (node) {
          node.blockchain.membership(signedMS, function (err) {
            if (err) console.error('Error:', err);
            else console.log('Successfully sent renew membership.');
          })
        })();
      if (!program.send && !program.store)
        process.stdout.write(signedMS);
    }));
  }));

program
  .command('leave [uid]')
  .description('Send \'leave\' membership request.')
  .action(withKeyPair(function (pub, sec, uid) {
    var certts = 0;
    async.waterfall([
      function (next){
        if (!uid){
          next('User ID is required');
          return;
        }
        // Look for possible certts
        async.waterfall([
          function (next) {
            withConnection(function (node){
              node.blockchain.memberships(decodeURIComponent(uid), next);
            })();
          },
          function (res, next){
            certts = res.sigDate;
            next();
          }
        ], next);
      },
      function (next) {
        withConnection(function (node) {
          async.parallel({
            current: function (next) {
              node.blockchain.current(function (err, current) {
                next(null, err ? null : current);
              });
            },
            parameters: function (next) {
              node.blockchain.parameters(function (err, json) {
                next(err, json);
              });
            }
          }, next);
        })();
      },
      function (res, next){
        var number = res.current ? res.current.number : 0;
        var hash = res.current ? res.current.hash : 'DA39A3EE5E6B4B0D3255BFEF95601890AFD80709';
        createMembership('OUT', res.parameters.currency, pub, sec, number, hash, uid, certts, next);
      },
    ], handleError(function (signedMS) {
      if (program.store)
        writeInHome("leave", signedMS);
      if (program.send)
        withConnection(function (node) {
          node.blockchain.membership(signedMS, function (err) {
            if (err) console.error('Error:', err);
            else console.log('Successfully sent leave membership.');
          })
        })();
      if (!program.send && !program.store)
        process.stdout.write(signedMS);
    }));
  }));

function createMembership (type, currency, pub, sec, number, hash, uid, certts, done) {
    var raw = "";
    async.waterfall([
      function (next){
        raw += "Version: 1" + '\n';
        raw += "Type: Membership" + '\n';
        raw += "Currency: " + currency + '\n';
        raw += "Issuer: " + base58.encode(pub) + '\n';
        raw += "Block: " + [number, hash].join('-') + '\n';
        raw += "Membership: " + type + '\n';
        if (uid) {
          raw += "UserID: " + uid + '\n';
        }
        if (certts) {
          raw += "CertTS: " + certts + '\n';
        }
        crypto.sign(raw, sec, next);
      },
      function (sig, next){
        raw += sig + '\n';
        next(null, raw);
      },
    ], done);
}

program
  .command('lookup [search]')
  .description('Show remote pubkey in ASCII armored format.')
  .action(withConnection(function (node, search) {
    async.waterfall([
      function (next){
        node.wot.lookup(search, next);
      },
      function (res, next){
        var matches = [];
        res.results.forEach(function(pubres){
          matches[pubres.pubkey] = [];
          pubres.uids.forEach(function(uidres){
            matches[pubres.pubkey].push(uidres.uid);
          });
        });
        next(null, matches);
      },
    ], handleError(function (res) {
      _(res).keys().forEach(function(pubkey){
        res[pubkey].forEach(function(uid){
          console.log(pubkey + ':' + uid);
        });
      });
    }));
  }));

program
  .command('cert [uid]')
  .description('Certify an identity matching <ui> found on remote server')
  .action(withConnection(function (node, uid) {
    async.waterfall([
      function (next){
        async.parallel({
          sCert: function (next) {
            getIdentityOf(uid, node, next);
          },
          blockRef: function (next) {
            async.waterfall([
              function (next) {
                withConnection(function (node) {
                  async.parallel({
                    current: function (next) {
                      node.blockchain.current(function (err, current) {
                        next(null, err ? null : current);
                      });
                    },
                    // parameters: function (next) {
                    //   node.blockchain.parameters(function (err, json) {
                    //     next(err, json);
                    //   });
                    // }
                  }, next);
                })();
              },
              function (res, next){
                var number = res.current ? res.current.number : 0;
                var hash = res.current ? res.current.hash : 'DA39A3EE5E6B4B0D3255BFEF95601890AFD80709';
                next(null, [number, hash].join('-'));
              }
            ], next);
          }
        }, next);
      },
      function (res, next){
        var sCert = res.sCert;
        var blockRef = res.blockRef;
        var blockNumber = blockRef.split('-')[0];
        var toBeSigned = ['UID:' + sCert.uid, 'META:TS:' + sCert.time, sCert.sig, 'META:TS:' + blockRef, ''].join('\n');
        if (program.yes)
          next(null, toBeSigned, blockNumber, sCert.pub);
        else {
          console.log('-----------------');
          console.log(toBeSigned);
          console.log('-----------------');
          ask.choose('You are about to sign this identity, continue?', false,
            async.apply(next, null, toBeSigned, blockNumber, sCert.pub),
            async.apply(next, 'Aborted.'));
        }
      },
      function (certification, target, sPub, next){
        sign(certification, function (err, sig, pub){
          next(err, certification + sig, pub, target, sPub);
        });
      },
      function (oCert, pub, target, sPub, next){
        var lines = oCert.split('\n');
        var inline = [
          base58.encode(pub),
          sPub,
          target,
          lines.slice(lines.length-1)
        ].join(':') + '\n';
        next(null, inline, sPub, lines.slice(0, 3).join('\n') + '\n');
      },
    ], handleError(function (inline, sPub, selfCert) {
      if (program.send)
        node.wot.add(sPub, selfCert, inline, function (err) {
          if (err) console.error('Error:', err);
          else console.log('Successfully sent certification of \'' + uid + '\'');
        })
      if (!program.send && !program.store)
        console.log(inline);
    }));
  }));

program
  .command('net-show')
  .description('Show current state of known peers of a given peer.')
  .action(withConnection(function (node) {
    var sources = [];
    async.waterfall([
      function (next) {
        node.network.peering.peers.get({ leaves: true }, next);
      },
      function(json, next) {
        async.parallel(json.leaves.map(function(leaf) {
          return function(callback) {
            var peer;
            async.waterfall([
              function(next) {
                node.network.peering.peers.get({ leaf: leaf }, next);
              },
              function(json, next) {
                peer = json.leaf.value;
                if (!peer) {
                  return next('No peer');
                }
                if (!peer.endpoints || peer.endpoints.length == 0) {
                  return next('No endpoint');
                }
                var match = peer.endpoints[0].match(/^BASIC_MERKLED_API( ([a-z_][a-z0-9-_.]*))?( ([0-9.]+))?( ([0-9a-f:]+))?( ([0-9]+))$/);
                if (!match) {
                  return next('No valid endpoint');
                }
                peer.host = match[2] || match[4] || match[6];
                peer.port = match[8];
                peer.record = peer.block.substr(0, 15);
                vucoin(peer.host, peer.port, next, { timeout: 1000 });
              },
              function(peerNode, next) {
                peerNode.blockchain.current(next);
              }
            ], function(err, data) {
              callback(null, { error: err, data: data, peer: peer || {} });
            });
          }
        }), next);
      },
      function (results, next){
        var table = new Table({
          head: ['Key', 'Host', 'Port', 'State', 'Record'],
          colWidths: [],
          chars: {'top': '' , 'top-mid': '' , 'top-left': '' , 'top-right': ''
            , 'bottom': '' , 'bottom-mid': '' , 'bottom-left': '' , 'bottom-right': ''
            , 'left': '' , 'left-mid': '-' , 'mid': '-' , 'mid-mid': '-'
            , 'right': '' , 'right-mid': '' , 'middle': ' | ' },
          style: { 'padding-left': 0, 'padding-right': 0, compact : true }
        });

        results = _.sortBy(results, function(res){ return !!res.error; });
        results.forEach(function (res) {
          table.push([res.peer.pubkey || '', res.peer.host || '', res.peer.port || '', res.error ? (res.error.code || res.error) : res.data.number, res.peer.record ]);
        });
        console.log(table.toString());
        next();
      }
    ], handleError(function (res) {
    }));
  }));

program
  .command('fwd-peers-from [host] [port] [depth]')
  .description('Forward peers')
  .action(withConnection(function (node, host, port) {
    var resultsMap = {};
    var resultsMapIP = {};
    async.waterfall([
      function(next) {
        crawlPeers(host, port, resultsMap, resultsMapIP, next);
      },
      function(next) {
        async.forEach(_.keys(resultsMap), function(pubkey, callback) {
          if (!pubkey || pubkey == "undefined") return callback();
          console.log('POST %s to %s', pubkey, [host, port].join(':'));
          node.network.peering.peers.post(getRawSignedPeer(resultsMap[pubkey].peer), function(err) {
            callback();
          });
        }, next);
      },
      function (next){
        var results = _.values(resultsMap);
        var table = new Table({
          head: ['Key', 'Host', 'Port'],
          colWidths: [],
          chars: {'top': '' , 'top-mid': '' , 'top-left': '' , 'top-right': ''
            , 'bottom': '' , 'bottom-mid': '' , 'bottom-left': '' , 'bottom-right': ''
            , 'left': '' , 'left-mid': '-' , 'mid': '-' , 'mid-mid': '-'
            , 'right': '' , 'right-mid': '' , 'middle': ' | ' },
          style: { 'padding-left': 0, 'padding-right': 0, compact : true }
        });

        results = _.sortBy(results, function(res){ return !!res.error; });
        results.forEach(function (res) {
          table.push([res.peer.pubkey || '', res.peer.host || '', res.peer.port || '']);
        });
        console.log(table.toString());
        next();
      }
    ], handleError(function (res) {
    }));
  }));

function crawlPeers(host, port, resultMap, resultsMapIP, done) {
  // Do not crawl twice the same node
  if (resultsMapIP[[host, port].join(':')]) return done();
  // Avoid future crawling on this address
  resultsMapIP[[host, port].join(':')] = {};
  var sourceNode;
  async.waterfall([
    function(next) {
      console.log('Crawling %s:%s', host, port);
      vucoin(host, port, next, { timeout: 2000 });
    },
    function(peerNode, next) {
      sourceNode = peerNode;
      async.waterfall([
        function (next) {
          sourceNode.network.peering.get(next);
        },
        function(peer, next) {
          if (!peer) {
            return next('No peer');
          }
          if (!peer.endpoints || peer.endpoints.length == 0) {
            return next('No endpoint');
          }
          var match = peer.endpoints[0].match(/^BASIC_MERKLED_API( ([a-z_][a-z0-9-_.]*))?( ([0-9.]+))?( ([0-9a-f:]+))?( ([0-9]+))$/);
          if (!match) {
            return next('No valid endpoint');
          }
          peer.host = match[2] || match[4] || match[6];
          peer.port = match[8];
          next(null, peer);
        }
      ], function(err, peer) {
        resultMap[peer.pubkey] = { error: err, peer: peer };
        resultsMapIP[[host, port].join(':')] = { error: err, peer: peer };
        sourceNode.network.peering.peers.get({ leaves: true }, next);
      });
    },
    function(json, next) {
      async.forEach(json.leaves, function(leaf, callback) {
        var peer;
        async.waterfall([
          function (next) {
            sourceNode.network.peering.peers.get({ leaf: leaf }, next);
          },
          function(json, next) {
            peer = json.leaf.value;
            if (!peer) {
              return next('No peer');
            }
            if (resultMap[peer.pubkey]) {
              return next('Already processed');
            }
            if (!peer.endpoints || peer.endpoints.length == 0) {
              return next('No endpoint');
            }
            var match = peer.endpoints[0].match(/^BASIC_MERKLED_API( ([a-z_][a-z0-9-_.]*))?( ([0-9.]+))?( ([0-9a-f:]+))?( ([0-9]+))$/);
            if (!match) {
              return next('No valid endpoint');
            }
            peer.host = match[2] || match[4] || match[6];
            peer.port = match[8];
            crawlPeers(peer.host, peer.port, resultMap, resultsMapIP, next);
          }
        ], function() {
          callback();
        });
      }, next);
    }], function(err) {
      done(err);
    });
}

program
  .command('revoke [uid]')
  .description('Revoke an identity matching <ui> found on remote server')
  .action(withConnection(function (node, uid) {
    async.waterfall([
      function (next){
        async.parallel({
          sCert: function (next) {
            getIdentityOf(uid, node, next);
          },
        }, next);
      },
      function (res, next){
        var sCert = res.sCert;
        var toBeSigned = ['UID:' + sCert.uid, 'META:TS:' + sCert.time, sCert.sig, 'META:REVOKE', ''].join('\n');
        var selfCert = ['UID:' + sCert.uid, 'META:TS:' + sCert.time, sCert.sig, ''].join('\n');
        if (program.yes)
          next(null, toBeSigned, selfCert, sCert.pub);
        else {
          console.log('-----------------');
          console.log(toBeSigned);
          console.log('-----------------');
          ask.choose('You are about to revoke this identity, continue?', false,
            async.apply(next, null, toBeSigned, selfCert, sCert.pub),
            async.apply(next, 'Aborted.'));
        }
      },
      function (revocation, selfCert, sPub, next){
        sign(revocation, function (err, sig, pub){
          console.log(sig);
          next(err, sPub, selfCert, sig);
        });
      },
    ], handleError(function (sPub, selfCert, sig) {
      if (program.send)
        node.wot.revoke(sPub, selfCert, sig, function (err) {
          if (err) console.error('Error:', err);
          else console.log('Successfully sent revocation of \'' + uid + '\'');
        })
      if (!program.send && !program.store)
        console.log([selfCert, sig].join('\n'));
    }));
  }));

function getIdentityOf (search, node, done) {
  async.waterfall([
    function (next){
      node.wot.lookup(search, next);
    },
    function (res, next) {
      var matches = [];
      var hash = {};
      res.results.forEach(function(pubres){
        pubres.uids.forEach(function(uidres){
          var day = moment.unix(uidres.meta.timestamp);
          var id = [uidres.uid, day.format('lll'), uidres.self.substring(0, 8)].join(' ');
          hash[id] = { pub: pubres.pubkey, uid: uidres.uid, time: uidres.meta.timestamp, sig: uidres.self };
          matches.push(id);
        });
      });
      if (matches.length == 0)
        next('No matching identity found on server');
      else {
        if (matches.length == 1)
          next(null, hash[matches[matches.length-1]]);
        else {
          matches = matches.concat(["None"]);
          ask.pick("Which one to sign?", matches, matches[matches.length-1], function (err, said) {
            if (said == 'None')
              next('Aborted.');
            else
              next(null, hash[said]);
          });
        }
      }
    }
  ], done);
}

function getPubkeyOf (search, node, done) {
  if (search.match(REG_PUBKEY)) {
    done(null, { pub: search });
  } else {
    getIdentityOf(search, node, done);
  }
}

function sign (msg, done) {
  async.waterfall([
    async.apply(getKeyPair),
    function (pair, next){
      crypto.sign(msg, pair.secretKey, function (err, sig) {
        next(err, sig, pair.publicKey);
      });
    },
  ], done);
}

function getKeyPair (done) {
  async.waterfall([
    function (next) {
      async.series({
        salt: getSalt,
        passwd: getPasswd
      }, next);
    },
    function (res, next) {
      crypto.getKeyPair(res.passwd, program.salt, next);
    }
  ], done);
}

function askSaltAndPasswd (done) {
  async.waterfall([
    function (next) {
      async.series({
        salt: getSalt,
        passwd: getPasswd
      }, next);
    },
    function (res, next) {
      program.salt = res.salt;
      program.passwd = res.passwd;
      next();
    }
  ], done);
}

function getSalt (done) {
  if (program.salt) done(null, program.salt);
  else ask.password('Salt', done);
}

function getPasswd (done) {
  if (program.passwd) done(null, program.passwd);
  else ask.password('Password', done);
}

program
  .command('import-ms [blockNumber] [host] [port]')
  .description('Import memberships from -h host and send them to remote [host]')
  .action(withConnection(function (node, blockNumber, host, port) {
    async.waterfall([
      function (next){
        node.blockchain.block(blockNumber, next);
      },
      function (res, next){
        var matches = [];
        var identities = {};
        var joins = {};
        res.identities.forEach(function (idty) {
          var sp = idty.split(':');
          identities[sp[0]] = { pubkey: sp[0], sig: sp[1], time: sp[2], userid: sp[3] };
        });
        res.joiners.forEach(function (join) {
          var sp = join.split(':');
          joins[sp[0]] = { pubkey: sp[0], sig: sp[1], time: sp[2] };
        });
        console.log('Block #%s...', blockNumber);
        async.forEachSeries(res.joiners, function (inlineMS, callback) {
          async.waterfall([
            function (next) {
              var sp = inlineMS.split(':');
              var pub = sp[0];
              var sig = sp[1];
              var num = sp[2];
              var fpr = sp[3];
              var raw = "";
              raw += "Version: 1" + '\n';
              raw += "Type: Membership" + '\n';
              raw += "Currency: " + res.currency + '\n';
              raw += "Issuer: " + pub + '\n';
              raw += "Block: " + [num, fpr].join('-') + '\n';
              raw += "Membership: " + 'IN' + '\n';
              raw += "UserID: " + identities[pub].userid + '\n';
              raw += "CertTS: " + identities[pub].time + '\n';
              raw += joins[pub].sig + '\n';
              vucoin(host, port, function (err, tgtNode) {
                if (err) {
                  console.error(err);
                  process.exit(1);
                }
                tgtNode.blockchain.membership(raw, function (err) {
                  if (err) console.error('Error:', err);
                  else console.log('Successfully sent join membership.');
                });
                next();
              });
            }
          ], callback);
        }, next);
      },
    ], handleError(function (res) {
    }));
  }));

program
  .command('import-idty [blockNumber] [host] [port]')
  .description('Import identities from -h host and send them to remote [host]')
  .action(withConnection(function (node, blockNumber, host, port) {
    async.waterfall([
      function (next){
        node.blockchain.block(blockNumber, next);
      },
      function (res, next){
        var matches = [];
        var identities = {};
        var joins = {};
        res.identities.forEach(function (idty) {
          var sp = idty.split(':');
          identities[sp[0]] = { pubkey: sp[0], sig: sp[1], time: sp[2], userid: sp[3], certs: [] };
        });
        res.certifications.forEach(function (cert) {
          var sp = cert.split(':');
          identities[sp[1]].certs.push({ from: sp[0], to: sp[1], block_number: sp[2], sig: sp[3] });
        });
        console.log('Block #%s...', blockNumber);
        async.forEachSeries(res.identities, function (inlineIdty, callback) {
          async.waterfall([
            function (next) {
              var sp = inlineIdty.split(':');
              var pub = sp[0];
              var sig = sp[1];
              var ts = sp[2];
              var uid = sp[3];
              var raw = "";
              raw += "UID:" + uid + '\n';
              raw += "META:TS:" + ts + '\n';
              raw += sig;
              var certs = "";
              identities[pub].certs.forEach(function (cert) {
                certs += [cert.from, cert.to, cert.block_number, cert.sig].join(':') + '\n';
              });
              vucoin(host, port, function (err, tgtNode) {
                if (err) {
                  console.error(err);
                  process.exit(1);
                }
                tgtNode.wot.add(pub, raw, certs, function (err) {
                  if (err) console.error('Error:', err);
                  else console.log('Successfully sent identity ' + uid);
                });
                next();
              });
            }
          ], callback);
        }, next);
      },
    ], handleError(function (res) {
    }));
  }));

program
  .command('import-lookup [uid] [host] [port]')
  .description('Import identities from -h host and send them to remote [host]')
  .action(withConnection(function (node, uid, host, port) {
    async.waterfall([
      function (next){
        node.wot.lookup(uid, next);
      },
      function (res, next){
        async.forEachSeries(res.results, function (entry, callback) {
          var pub = entry.pubkey;
          async.forEachSeries(entry.uids, function (user, callback2) {
            async.waterfall([
              function (next) {
                var uid = user.uid;
                var sig = user.self;
                var ts = user.meta.timestamp;
                var raw = "";
                raw += "UID:" + uid + '\n';
                raw += "META:TS:" + ts + '\n';
                raw += sig;
                var certs = "";
                if (program.certs) {
                  user.others.forEach(function (cert) {
                    certs += [cert.pubkey, pub, cert.meta.block_number, cert.signature].join(':') + '\n';
                  });
                }
                if (!certs) {
                  raw += '\n';
                }
                vucoin(host, port, function (err, tgtNode) {
                  if (err) {
                    console.error(err);
                    process.exit(1);
                  }
                  tgtNode.wot.add(pub, raw, certs, function (err) {
                    if (err) console.error('Error:', err);
                    else console.log('Successfully sent identity ' + uid);
                  });
                  next();
                });
              }
            ], callback2);
          }, callback);
        }, next);
      },
    ], handleError(function (res) {
    }));
  }));

program
  .command('wotviz')
  .description('Exports current Web of Trust under .dot file format (graphviz usage)')
  .action(withConnection(function (node) {
    var links = [];
    var mapLinks = {};
    async.waterfall([
      async.apply(node.wot.members),
      function (json, next) {
        async.forEach(json.results, function (member, callback) {
          async.waterfall([
            async.apply(node.wot.certifiedBy, member.uid),
            function (res, next) {
              mapLinks[member.uid] = [];
              res.certifications.forEach(function (cert) {
                mapLinks[member.uid].push(cert.uid);
              });
              next();
            }
          ], callback);
        }, next);
      },
      function (next) {
        var members = _(mapLinks).keys();
        var bidirectionnals = {};
        members.forEach(function (source) {
          bidirectionnals[source] = [];
          members.forEach(function (target) {
            if (~mapLinks[target].indexOf(source) && ~mapLinks[source].indexOf(target)) {
              bidirectionnals[source].push(target);
            }
          });
        });
        var bidirs = [];
        members.forEach(function (member) {
          mapLinks[member].forEach(function (target) {
            if (~bidirectionnals[member].indexOf(target)) {
              var notYetWritten = bidirs.indexOf(member + target) == -1;
              if (notYetWritten) {
                links.push('"' + member + '" -> "' + target + '" [dir=both];');
                bidirs.push(member + target);
                bidirs.push(target + member);
              }
            }
            else
              links.push('"' + member + '" -> "' + target + '" [color=gray];');
          });
        });
        next();
      },
      function (next) {
        var content = 'digraph G {\n';
        links.forEach(function (lnk) {
          content += '\t' + lnk + '\n';
        });
        content += '}'
        console.log(content);
        next();
      }
    ], handleError(function (res) {
    }));
  }));

program
  .command('transfer [amount] [recipient] [comment]')
  .description('Transfer an amount of coins to a single recipient.')
  .action(withConnectionAndKeyPair(function (node, pub, sec, amount, recipient, comment) {
    var sources = [];
    var choices = {};
    var currency = '';
    var raw = "";
    async.waterfall([
      function (next) {
        if (!amount || !recipient) {
          next('Amount and recipient are required');
          return;
        }
        node.tx.sources(base58.encode(pub), next);
      },
      function (json, next){
        currency = json.currency;
        var i = 0;
        var cumulated = 0;
        while (i < json.sources.length) {
          var src = json.sources[i];
          sources.push({
            'type': src.type,
            'amount': src.amount,
            'number': src.number,
            'hash': src.fingerprint
          });
          cumulated += src.amount;
          i++;
        }
        if (cumulated < amount) {
          next('You do not have enough coins! (' + cumulated + ' ' + currency + ' left)');
        }
        else {
          getPubkeyOf(recipient, node, next);
        }
      },
      function (idty, next) {
        recipient = idty.pub;
        var proposals = [];
        sources.forEach(function (src) {
          var proposal = [src.type, src.number, src.hash.substring(32)].join(':') + ' (' + src.amount + ' coins)';
          choices[proposal] = src;
          proposals.push(proposal);
        });
        var selected = [];
        var totalAmount = 0;
        async.doWhilst(
          function (next) {
            async.waterfall([
              async.apply(ask.select, 'Which sources to spend?', proposals, proposals[0]),
              function (selections, next) {
                totalAmount = 0;
                selections.forEach(function (item) {
                  var src = choices[item];
                  selected.push(src);
                  totalAmount += src.amount;
                });
                next();
              }
            ], next);
          },
          function () {
            var notEnough = totalAmount < amount;
            if (notEnough) console.log('\n/!\\ Total amount is below ' + amount + '! Choose other sources.\n');
            return notEnough;
          },
          function (err) {
            next(err, selected);
          }
        );
      },
      function (sources, next){
        var inputSum = 0;
        var issuer = base58.encode(pub);
        raw += "Version: 1" + '\n';
        raw += "Type: Transaction\n";
        raw += "Currency: " + currency + '\n';
        raw += "Issuers:\n";
        raw += issuer + '\n';
        raw += "Inputs:\n";
        sources.forEach(function (src) {
          raw += ['0', src.type, src.number, src.hash, src.amount].join(':') + '\n';
          inputSum += src.amount;
        });
        raw += "Outputs:\n";
        raw += [recipient, amount].join(':') + '\n';
        if (inputSum - amount > 0) {
          // Rest back to issuer
          raw += [issuer, inputSum - amount].join(':') + '\n';
        }
        raw += "Comment: " + (comment || "") + "\n";
        var toBeSigned = raw;
        if (program.yes)
          next(null, toBeSigned, blockNumber, sCert.pub);
        else {
          console.log('-----------------');
          console.log(toBeSigned);
          console.log('-----------------');
          ask.choose('You are about to sign this transaction, continue?', false,
            async.apply(next, null, toBeSigned),
            async.apply(next, 'Aborted.'));
        }
      },
      function (raw, next){
        sign(raw, next);
      },
      function (sig, pub, next) {
        raw += sig + '\n';
        node.tx.process(raw, function (err) {
          if (err) console.error('Error:', err);
          else console.log('Successfully sent transaction.');
        });
      },
    ], handleError(function (res) {
    }));
  }));

program
  .command('peer')
  .description('Show remote peering informations.')
  .action(connect(function (node) {
    node.network.peering.get(proxy(function (res) {
      console.log("Currency: %s", res.currency);
      console.log("Public key: %s", res.fingerprint);
      res.endpoints.forEach(function(endpoint, index){
        console.log('Endpoint %s: %s', index, endpoint);
      });
    }));
    return;
  }));

program
  .command('balance [uid|pubkey]')
  .description('Show available sources & computed balance of given uid|pubkey.')
  .action(withConnection(function (node, pubkey) {
    if(!pubkey){
      console.error('pubkey is required');
      return;
    }
    var sources = [];
    async.waterfall([
      function (next) {
        // Get the pubkey from pubkey|uid parameter
        async.waterfall([
          function (next) {
            getPubkeyOf(pubkey, node, next);
          },
          function (idty, next) {
            pubkey = idty.pub;
            next();
          }
        ], next);
      },
      function (next) {
        node.tx.sources(pubkey, next);
      },
      function (json, next){
        currency = json.currency;
        var i = 0;
        var cumulated = 0;
        json.sources.forEach(function (src) {
          sources.push({
            'type': src.type,
            'amount': src.amount,
            'number': src.number,
            'hash': src.fingerprint
          });
          cumulated += src.amount;
        });
        console.log("Credit: " + cumulated);
        console.log("-------------------");
        var table = new Table({
          head: ['Value', 'From', 'Source FPR'],
          colWidths: [Math.min(6, (""+cumulated).length + 5), 5, 41],
          chars: {'top': '' , 'top-mid': '' , 'top-left': '' , 'top-right': ''
               , 'bottom': '' , 'bottom-mid': '' , 'bottom-left': '' , 'bottom-right': ''
               , 'left': '' , 'left-mid': '' , 'mid': '' , 'mid-mid': ''
               , 'right': '' , 'right-mid': '' , 'middle': '' },
          style: { 'padding-left': 0, 'padding-right': 0, compact : true }
        });

        sources = _(sources).sort(function (a, b) { return a.amount < b.amount });
        sources.forEach(function (src) {
          table.push([src.amount, src.type, src.hash]);
        });
        console.log(table.toString());
        next();
      },
    ], handleError(function (res) {
    }));
  }));

program
  .command('coins-get [owner]')
  .description('Get a random set of coins with given values, owned by [owner].')
  .action(connect(function (owner, node) {
    if(!owner){
      console.error('owner is required');
      return;
    }
    if(!program.pay){
      console.error("Requires --pay parameter");
      return;
    }
    var coins = {};
    var amendments = {};
    node.hdc.coins.list(owner, proxy(function (res) {
      async.forEachSeries(res.coins, function (id, callback) {
        var tx = new hdc.Transaction();
        tx.coins = [];
        tx.coins.push(id);
        var c = tx.getCoins()[0];
        getAmendment(amendments, c, node, function (err, amount) {
          if (!err) {
            // Coins per value
            coins[amount] = coins[amount] || [];
            coins[amount].push(c);
          }
          callback(err);
        });
      }, function (err) {

        if(err){
          console.error(err);
          return;
        }

        var get = {};
        var err = null;
        program.pay.forEach(function (coin) {
          var amount = parseInt(coin.value);
          if(coins[amount] && coins[amount].length > 0){
            var c = coins[amount][0];
            get[c.issuer] = get[c.issuer] || [];
            get[c.issuer].push(c);
            coins[amount].splice(0,1); // No more available
          }
          else{
            err = 'You do not have enough coins of value (' + amount + ')';
            return;
          }
        });

        if(err){
          console.error(err);
          return;
        }

        var keys = _(get).keys();
        var str = '';
        keys.sort().reverse();
        keys.forEach(function (key) {
          str += str == '' ? '' : ',';
          str += key;
          get[key].forEach(function (coin) {
            str += ':' + [coin.amNumber, coin.coinNumber].join('-');
          });
        });
        console.log(str);
      });
    }));
    return;
  }));

program
  .command('utc-timestamp')
  .description('Get current timestamp for UTC+0 timezone.')
  .action(function () {
    var now = new Date();
    console.log(Math.floor(now.getTime()/1000) + now.getTimezoneOffset()*60);
  });

program.parse(process.argv);

function connect(auth, callback) {
  if (arguments.length == 1) {
    callback = auth;
    auth = true;
  }
  return function () {
    var cbArgs = arguments;
    vucoin(program.host, program.port, function (err, node) {
      if(err){
        console.error(err);
        return;
      }
      cbArgs.length > 0 && cbArgs.length--;
      cbArgs[cbArgs.length++] = node;
      callback.apply(this, cbArgs);
    });
  };
}

function proxy(callback){
  return function (err, res) {
    if(err){
      if(err.code)
        console.error("Error: " + err.code);
      else
        console.error("Error: " + err);
      process.exit(1);
      return;
    }
    else callback(res);
  }
}

function splitCoins (arg) {
  var strings = arg.split(',');
  var values = [];
  for(var i = 0; i < strings.length - 1; i = i + 2){
    values.push({
      base: parseInt(strings[i], 10),
      power: parseInt(strings[i+1], 10)
    });
  }
  return values;
}

function getLastIssuedCoin(tx) {
  if (tx.type == 'ISSUANCE') {
    // Get last coin of the list
    var coins = tx.getCoins();
    return coins[coins.length - 1];
  } else if (tx.type == 'CHANGE') {
    // Get last coin of the list with no TRANSACTION_ID
    var coins = tx.getCoins();
    var lastCoin = null;
    var i = 0;
    while (coins[i] && !coins[i].transaction) {
      lastCoin = coins[i];
      i++;
    }
    return lastCoin;
  } else {
    // No issued coin exists
    return null;
  }
}

function toChanges (str) {
  var changesStr = (str || "")
    .replace(/"/g, '')
    .replace(/\+/g, ';+')
    .replace(/-/g, ';-');
  var changes = [];
  changesStr.split(';').forEach(function(item){
    if (item != "") {
      changes.push(item);
    }
  });
  return changes;
}

function filterPlus (item){
  return item.match(/\+/);
}

function filterMinus (item){
  return item.match(/-/);
}

function withoutPlusOrMinus(item){
  return item.substr(1);
}

function getAmendment (amendments, c, node, done) {
  async.waterfall([
    function (next){
      if (amendments[c.amNumber]) {
        next(null, amendments[c.amNumber]);
      } else {
        node.hdc.amendments.promoted(c.amNumber, proxy(function (res) {
          amendments[c.amNumber] = res;
          next(null, amendments[c.amNumber]);
        }));
      }
    },
    function (am, next){
      done(null, coinValue(c.coinNumber, am));
    },
  ], done);
}

function coinValue (coinNumber, am) {
  var power = am.coinBase;
  var decr = coinNumber;
  am.coinList.forEach(function(quantity){
    if (decr <= quantity) {
      return;
    }
    decr -= quantity;
    power++;
  });
  return Math.pow(2, power);
}

function handleError (success) {
  return function () {
    if (arguments[0])
      console.error(arguments[0]);
    else {
      var args = Array.prototype.slice.call(arguments);
      success.apply(success, args.slice(1));
    }
  };
}

function withKeyPair (parameters, done) {
  if (arguments.length == 1) {
    done = parameters;
    parameters = [];
  }
  return withParams(['salt', 'passwd'].concat(parameters), function () {
    var args = Array.prototype.slice.call(arguments);
    crypto.getKeyPair(program.passwd, program.salt, function (err, pair) {
      done.apply(done, [pair.publicKey, pair.secretKey].concat(args));
    });
  });
}

function withConnection (parameters, done) {
  if (arguments.length == 1) {
    done = parameters;
    parameters = [];
  }
  return withParams(['host', 'port'].concat(parameters), function () {
    var args = Array.prototype.slice.call(arguments);
    vucoin(program.host, program.port, function (err, node) {
      if (err) {
        console.error(err);
        process.exit(1);
      }
      done.apply(done, [node].concat(args));
    });
  });
}

function withConnectionAndKeyPair (parameters, done) {
  if (arguments.length == 1) {
    done = parameters;
    parameters = [];
  }
  return withParams(['host', 'port'].concat(parameters), function () {
    var args = Array.prototype.slice.call(arguments);
    async.waterfall([
      function (next) {
        askSaltAndPasswd(next);
      },
      function (next) {
        async.parallel({
          node: function (next) {
            vucoin(program.host, program.port, function (err, node) {
              if (err) {
                console.error(err);
                process.exit(1);
              }
              next.apply(next, [null, node]);
            });
          },
          keys: function (next) {
            crypto.getKeyPair(program.passwd, program.salt, function (err, pair) {
              next.apply(next, [null, pair.publicKey, pair.secretKey]);
            });
          }
        }, function (err, res) {
          next.apply(next, [res.node].concat(res.keys).concat(args));
        });
      }
    ], done);
  });
}

function withParams (parameters, done) {
  return function () {
    var err = null;
    parameters.forEach(function(p){
      if(!err && !program[p]){
        err = "Requires --" + p + " parameter";
      }
    });
    if (err) {
      console.error(err);
      process.exit(1);
    }
    done.apply(done, arguments);
  };
}

function writeInHome (fileName, content) {
  var homePath = process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE;
  var ucoinPath = homePath + '/.ucoin/' + (program.user ? program.user : 'defaut');
  mkdirp.sync(ucoinPath, '0770');
  fs.writeFileSync(ucoinPath + '/' + fileName, content, 'utf8');
}

function readInHome (fileName) {
  var homePath = process.env.HOME || process.env.HOMEPATH || process.env.USERPROFILE;
  var ucoinPath = homePath + '/.ucoin/' + (program.user ? program.user : 'defaut');
  var filePath = ucoinPath + '/' + fileName;
  return fs.existsSync(filePath) ? fs.readFileSync(filePath, 'utf8') : '';
}

function split (pattern) {
  return function (str) {
    return str.split(pattern);
  };
}

String.prototype.trim = function(){
  return this.replace(/^\s+|\s+$/g, '');
};

String.prototype.unix2dos = function(){
  return this.dos2unix().replace(/\n/g, '\r\n');
};

String.prototype.dos2unix = function(){
  return this.replace(/\r\n/g, '\n');
};

String.prototype.coin = function(){
  var matches = this.match(/([A-Z\d]{40})-(\d+)-(\d+)(:([A-Z\d]{40})-(\d+))?/);
  if(matches && matches.length == 7){
    return {
      issuer: matches[1],
      amNumber: parseInt(matches[2], 10),
      coinNumber: parseInt(matches[3], 10),
      transaction: matches[4] && {
        sender: matches[5],
        number: matches[6]
      }
    };
  } else {
    return null;
  }
};

Date.prototype.utc = function(){
  return new Date();
};

Date.prototype.utcZero = function(){
  return new Date(this.getTime() + this.getTimezoneOffset()*60*1000);
};

Date.prototype.timestamp = function(){
  return Math.floor(this.getTime() / 1000);
};


function getRawSignedPeer(json) {
  var raw = "";
  raw += "Version: " + json.version + "\n";
  raw += "Type: Peer\n";
  raw += "Currency: " + json.currency + "\n";
  raw += "PublicKey: " + json.pubkey + "\n";
  raw += "Block: " + json.block + "\n";
  raw += "Endpoints:" + "\n";
  (json.endpoints || []).forEach(function(ep){
    raw += ep + "\n";
  });
  if (json.signature)
    raw += json.signature + '\n';
  return dos2unix(raw);
}

function dos2unix(str){
  return str.replace(/\r\n/g, '\n');
}
